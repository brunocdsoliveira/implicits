\section{Conclusion}
\label{sec:conclusion}

Our main contribution is the development of the implicit
calculus $\ourlang$. This calculus isolates and formalizes the key
ideas of Scala implicits and provides a simple model for language designers 
interested in developing similar mechanisms for their own languages. 
In addition, $\ourlang$ supports higher-order rules and partial resolution, 
which add considerable expressiveness to the calculus.

Implicits provide an interesting alternative to conventional GP 
mechanisms like type classes or concepts. By decoupling resolution 
from a particular type of interfaces, implicits make resolution 
more powerful and general. Furthermore, this decoupling has other benefits too. 
For example, by modeling concept interfaces as conventional types, those interfaces can 
be abstracted as any other types, avoiding the issue of second class interfaces 
that arise with type classes or concepts. 

Ultimately, all the expressiveness offered by $\ourlang$
offers a wide-range of possibilities for new generic programming applications.

%%In particular, 
%%resolution for any types local and nested scoping for implicits 
 
%%features for
%%generic programming, nested scoping and resolution of any types.

%%We present a formal type system for the calculus and provide semantics via a
%%translation to System F. We prove that the translation preserves types and thus
%%establish type soundness for $\ourlang$.

%%The calculus provides a formal platform for the development of
%%a realistic source language. Our small source language already shows 
%%how to add implicit instantiation on top of the calculus. In further
%%work we intend to develop this into a full-fledged language.



% integrates key features in GP, while at the same
% time being minimalistic. The calculus supports nested scoping,
% overlapping rules, higher-order rules and rule resolutions. 
%
% and encodings of existing GP practice. 
% 
% In the calculus, two key features -- scoping and resolution -- of many
% GP mechanisms were put in the spotlight, and we
% offered answers to two challenging, and essentially unsolved issues in
% the literature: how to support coherence for overlapping rules in
% nested scoping; and how to support resolution with higher-order
% rules. Such properties of scoping and resolution have not received
% appropriate attention in the past. 
% 
% of GP, which has been an
% increasingly popular trend in programming languages such as Haskell, Scala,
% Java, C++ and Agda. 


%%Both of these shortcommings hinder the development of applications 
%%that rely on sophisticated implicit programming mechanisms, as
%%document previously in the literature~\cite{derivable,}.

%Future work includes the design of a source language with a powerful 
%modularity construct (which could be a form of modules, OO classes 
%or records with associated types) to model ``type-class'' style
%interfaces. Type inference and additional source-level constructs on top of
%$\ourlang$ also deserve further attention.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../Main"
%%% End: 


