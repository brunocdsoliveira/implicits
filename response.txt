We thank all reviewers for the helpful comments.

* Presentation Improvements

Thank you for the suggestions to improve the presentation.  We will
definitely take them into account. In particular we are very happy
with the comment on making a punchline at the end of Section 2 on
stability as the key idea; we agree that this will be very helpful to
better convey the key idea to readers.

We would like to clarify the need for tracking the type variables
referred to on p.13. Consider for example resolving the type

		ρ = b.b → b

  against the environment 

  		Γ0 = ∀c.c → c ~> id, a, a → a ~> f 

  i.e.

	     	Γ0 ⊢ ρ

  Imagine what would happen if we did not track the type variables. Firstly,
  using rule R-TAbs we would extend the environment with b 

  		Γ1 = Γ0, b

  and resolve the simple type

	     	Γ1 ⊢ b → b

  which would get stuck on a → a when considering which rule matches in Γ1. In particular,
  L-RuleMatch does not apply because a → a is different from b → b. Also L-RuleNoMatch does
  not apply because a → a and b → b unify under the substitution [b := a]; thus skipping 
  rule a → a would be deemed unstable.

  However, there is an error in the above reasoning. Code inlining cannot
  result in b being instantiated to a, because b is not free in the environment 
  Γ0, which is the environment at the point in the code where the query happens.
  To avoid this reasoning error, we keep track of the variables that are free
  in the environment in Γ0. These are the variables that can be substituted, while
  the variables added to the environment by rule R-TAbs cannot be substituted.

  We will integrate this example in the text.


* Bugs in the typing rules

  We do indeed intentionally abuse the notation (although we would not call
  that bugs), but are happy to reformulate as you suggest to clarify
  the intended meaning.

  TODO: Should we say something about Show?

* The intended type of bad on p. 5 is actually bad :: a -> a, 
  and not bad :: Trans a => a -> a, because we want to force
  the resolution of Trans at the definition of bad instead of
  the call sites of bad.

* Naming the implicit parameters only works if you want to directly
  refer to them. It does not work in the case of recursive
  resolution. For example consider the program:

  \(Int => Bool) . \Int . ?Bool

  where multiple rules have to be combined to resolve ?Bool.
  In such cases the system figures out how to combine the rules; the programmer
  does not have to write the composition himself.

* The β >Γ α judgement is related to the tracking of variables and the checking of
  stability discussed above. 
  It performs another necessary sanity check: a substitution [α := β] (*) due to
  inlining is only possible if β is in scope of α. This property is verified in
  terms of the relative positions of α and β in the environment: the latter must
  appear before the former. 
  
  (*) This generalizes to substitutions [α := σ] where β is a free variable in σ.

* Our work is on an improvement to the implicit calculus. Our
  improvement is mainly about working out the restrictions needed to
  ensure coherence. So it does not add any new programming features
  per se. Practical examples illustrating the uses of
  implicits were already presented in the following two cited papers:

	B. C. d. S. Oliveira, A. Moors, and M. Odersky. 2010. Type classes as objects
	and implicits. In OOPSLA. ACM, New York, NY, USA.

	B. C. d. S. Oliveira, T. Schrijvers, W. Choi, W. Lee, and K. Yi. 2012.  The
	Implicit Calculus: A New Foundation for Generic Programming. In PLDI ’12. ACM,
	New York, NY, USA. 

  Thus our paper focuses only on coherence and examples about
  coherence. 
